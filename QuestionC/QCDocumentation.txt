This is a documentation for the GeoDistributedLRU library developpedMain variables:self.client: stores the client cache instance (the client in which the cache is stored)self.fallbackClient: stores the backup client cache instance (the client to use in case the main client crashes)self.backupClients: stores the backup client cache instance on which cache must be written in real time to assure data consistency and availabilityself.cacheExpirationTime: stores the default amount of time cache data is kept before it expiresself.oldClient: stores a client cache instance in case of fallback in order to go back to initial client after server is back online.Methods:setBackupClients(self,clientsList): Set a list of clients intances (clientsList) on which new cache data must be replicated after being added to the main clientsetFallbackClient(self,fallbackClient): set a client instance (fallbackClient) that will serve as fallback if the main client crashesinitializeFallbackClient(self): transfers the main client instance's cache to fallback client instance's cache and sets fallback client instance as the main client instancereplicateDataCacheKey(self,cacheKey,cacheData): write new cache contents to other clients instances cache.generateCacheKey(self): Generates a unique cache key and returns it as a stringgetCacheData(self,cacheKey): gets cache content from main client instance's cache based on cacheKey (string) valuesetCacheData(self,cacheKey, dataToCache): adds cache content (dataToCache) to the main client instance's cache and provides the cache Key (cacheKey) under which the content should be savedmodifyCacheData(self,cacheKey,newCacheData): modifies cache content with new cache data (newCacheData) based on cache key (cacheKey)Required Python Packages:uuid (for unique numbers/id generation)memcached (for distributed caching)Missing Functionalities:-Data availability from the closest region: i did not really grasp the  meaning of this requirement-Simplicity: even though the code is neither long nor complex. It may not be easy to integrate to other services due to the facts that it is written in python.Criteria met:- Cache can expire: the memcached package provides simple mechanisms to specify the expiration time of the cache when setting it.-Data consistency across regions: new cache data on the main client's intance is also added to the clients of other regions. Hence the data consistency across the regions-Resilient to network failures or crashes: the fallback mechanism ensures that another client instance can be accessed after a crash and it also contains the old client's cache.- Near real time replication of data across Geolocation: new cache data is written to other client intances as well.Another functionality:function implemented to managed current cache access for modification (modifyCacheData()Another way to tackle the latency issue could be the usage of the distributed design pattern Reactor. It has the following advantages:- Provides minimum latency and maximum throughput-Increases modularity, reutilisability, portabilityHowever the level of difficulty of its implementation would depend on the architecture of the Ormuco stack because it has limitations such as the facts that it can only be used with an Operating system that has handles and it complexifies the debugging process